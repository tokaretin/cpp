
💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡
💥манипулятор потока
std::cout << std::boolalpha;  

/*std::boolalpha - это манипулятор потока в C++, который влияет на формат вывода логических (boolean)
значений в стандартный поток вывода std::cout. Когда манипулятор std::boolalpha установлен, 
логические значения будут выводиться как "true" или "false" (строковые значения), а не как числа (1 или 0).*/

// Пример:
#include <iostream>

int main() {
    bool myBool = true;
    
    std::cout << std::boolalpha;  // Устанавливаем формат вывода для логических значений как true/false
    std::cout << myBool << std::endl;  // Выводится "true"
    
    std::cout << std::noboolalpha;  // Сбрасываем формат вывода для логических значений
    std::cout << myBool << std::endl;  // Выводится "1" (как число)
    
    return 0;
}
/*В этом примере, после установки std::boolalpha, std::cout выводит значение myBool как "true", 
а не как "1". Это полезно, когда вам нужно читабельный текстовый вывод для логических значений.*/

💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡
💥Макрос
#define ENDL std::endl
/*Директива препроцессора #define используется для создания макросов*/
// Используя макрос ENDL, можно более компактно вставлять std::endl в коде. 
// Например:
#include <iostream>

// Использование макроса может сделать код более читаемым
int main() {
    std::cout << "Привет, мир!" << ENDL; 
    return 0;
}

// 1.Определение константы:
#define MAX_VALUE 100

int main() {
    int value = MAX_VALUE;
    return 0;
}

// 2.Упрощение кода:
#define LOG(message) std::cout << message << std::endl

int main() {
    LOG("This is a log message");
    return 0;
}

// 3.Математические выражения:
#define SQUARE(x) ((x) * (x))

int main() {
    int side = 5;
    int area = SQUARE(side);  // Будет раскрыто как ((5) * (5))
    return 0;
}

// 4.Условные макросы:
#define DEBUG  // Раскомментируйте эту строку для включения режима отладки

int main() {
    #ifdef DEBUG
        std::cout << "Debug mode enabled" << std::endl;
    #endif
    return 0;
}

// 5.Конкатенация строк:
#define GREETING_PREFIX "Hello, "

int main() {
    std::cout << GREETING_PREFIX "world!" << std::endl;  // Будет раскрыто как "Hello, " "world!"
    return 0;
}

💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡
💥Указатели
#include <iostream>

int main()
{
    // первый пример
    int i = 11;
    std::cout << "Адрес где лежит переменная i: " << &i;

    E;
    // второй пример
    i = 15;
    int* pi = &i;
    std::cout << "Разименовываем *pi и загружаем число (int* pi = &i;) 15: " << *pi << std::endl; // разименовать pi и загрузить число 15

    i = 100;
    std::cout << *pi << std::endl; // разименовать pi и загрузить число 100

    // третьий пример
    *pi = 28;
    std::cout << i << std::endl; // разименовать pi и загрузить число 28

    // четвертый пример
    int a = 10;   
    int b = 5;    
    int *pa = &a; // Создаем указатель на целое число pa и присваиваем ему адрес переменной a. Теперь pa указывает на a.
    pa = &b;      // Изменяем значение указателя pa, теперь он указывает на переменную b, а не на a.
    *pa = 20;     // Разыменовываем указатель pa и присваиваем значение 20 переменной, на которую он указывает, то есть переменной b.

    std::cout << a << " " << b << std::endl; // Выводим значения переменных a и b. Значение a остается равным 10, а значение b изменено на 20.
}

💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡
💥Фибаначи
#include <iostream>

int fib(int n)
{
    if (n == 0 || n == 1)
    {
        return 1;
    }

    return fib(n - 1) + fib(n - 2);
}

int fib2(int n)
{
    return n <= 1 ? 1 : fib2(n - 1) + fib2(n - 2);
}

int main()
{
    for (int i = 0; i < 10; i++)
    {
        std::cout << i + 1 << " - " << fib2(i) << std::endl;
    }
    return 0;
}

// Число Фибоначчи для n = 1: Формула: F(1) = F(1-1) = F(0)                         = 1 (значение по умолчанию)
// Число Фибоначчи для n = 1: Формула: F(1) = F(1-1) = F(0)                         = 1 (значение по умолчанию)
// Число Фибоначчи для n = 2: Формула: F(2) = F(2-1) + F(2-2) = F(1) + F(0) = 1 + 1 = 2
// Число Фибоначчи для n = 3: Формула: F(3) = F(3-1) + F(3-2) = F(2) + F(1) = 2 + 1 = 3
// Число Фибоначчи для n = 4: Формула: F(4) = F(4-1) + F(4-2) = F(3) + F(2) = 3 + 2 = 5
// Число Фибоначчи для n = 5: Формула: F(5) = F(5-1) + F(5-2) = F(4) + F(3) = 5 + 3 = 8
// Число Фибоначчи для n = 6: Формула: F(6) = F(6-1) + F(6-2) = F(5) + F(4) = 8 + 5 = 13
// Число Фибоначчи для n = 4: Формула: F(7) = F(7-1) + F(7-2) = F(6) + F(5) = 13 + 8 = 21
// Число Фибоначчи для n = 5: Формула: F(8) = F(8-1) + F(8-2) = F(7) + F(6) = 21 + 13 = 34
// Число Фибоначчи для n = 6: Формула: F(9) = F(9-1) + F(9-2) = F(8) + F(7) = 34 + 21 = 55

💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡
