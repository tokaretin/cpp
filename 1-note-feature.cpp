
💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡
💥манипулятор потока
std::cout << std::boolalpha;  

/*std::boolalpha - это манипулятор потока в C++, который влияет на формат вывода логических (boolean)
значений в стандартный поток вывода std::cout. Когда манипулятор std::boolalpha установлен, 
логические значения будут выводиться как "true" или "false" (строковые значения), а не как числа (1 или 0).*/

// Пример:
#include <iostream>

int main() {
    bool myBool = true;
    
    std::cout << std::boolalpha;  // Устанавливаем формат вывода для логических значений как true/false
    std::cout << myBool << std::endl;  // Выводится "true"
    
    std::cout << std::noboolalpha;  // Сбрасываем формат вывода для логических значений
    std::cout << myBool << std::endl;  // Выводится "1" (как число)
    
    return 0;
}
/*В этом примере, после установки std::boolalpha, std::cout выводит значение myBool как "true", 
а не как "1". Это полезно, когда вам нужно читабельный текстовый вывод для логических значений.*/

💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡
💥Макрос
#define ENDL std::endl
/*Директива препроцессора #define используется для создания макросов*/
// Используя макрос ENDL, можно более компактно вставлять std::endl в коде. 
// Например:
#include <iostream>

// Использование макроса может сделать код более читаемым
int main() {
    std::cout << "Привет, мир!" << ENDL; 
    return 0;
}

// 1.Определение константы:
#define MAX_VALUE 100

int main() {
    int value = MAX_VALUE;
    return 0;
}

// 2.Упрощение кода:
#define LOG(message) std::cout << message << std::endl

int main() {
    LOG("This is a log message");
    return 0;
}

// 3.Математические выражения:
#define SQUARE(x) ((x) * (x))

int main() {
    int side = 5;
    int area = SQUARE(side);  // Будет раскрыто как ((5) * (5))
    return 0;
}

// 4.Условные макросы:
#define DEBUG  // Раскомментируйте эту строку для включения режима отладки

int main() {
    #ifdef DEBUG
        std::cout << "Debug mode enabled" << std::endl;
    #endif
    return 0;
}

// 5.Конкатенация строк:
#define GREETING_PREFIX "Hello, "

int main() {
    std::cout << GREETING_PREFIX "world!" << std::endl;  // Будет раскрыто как "Hello, " "world!"
    return 0;
}

💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡
💥Указатели
#include <iostream>

int main()
{
    // первый пример
    int i = 11;
    std::cout << "Адрес где лежит переменная i: " << &i;

    E;
    // второй пример
    i = 15;
    int* pi = &i;
    std::cout << "Разименовываем *pi и загружаем число (int* pi = &i;) 15: " << *pi << std::endl; // разименовать pi и загрузить число 15

    i = 100;
    std::cout << *pi << std::endl; // разименовать pi и загрузить число 100

    // третьий пример
    *pi = 28;
    std::cout << i << std::endl; // разименовать pi и загрузить число 28

    // четвертый пример
    int a = 10;   
    int b = 5;    
    int *pa = &a; // Создаем указатель на целое число pa и присваиваем ему адрес переменной a. Теперь pa указывает на a.
    pa = &b;      // Изменяем значение указателя pa, теперь он указывает на переменную b, а не на a.
    *pa = 20;     // Разыменовываем указатель pa и присваиваем значение 20 переменной, на которую он указывает, то есть переменной b.

    std::cout << a << " " << b << std::endl; // Выводим значения переменных a и b. Значение a остается равным 10, а значение b изменено на 20.
}

💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡

💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡💡
