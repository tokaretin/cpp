#include <iostream>

int main()
{
    int a = 5;                 // Создаем целочисленную переменную a и присваиваем ей значение 5.
    int *pa = &a;              // Создаем указатель на целое число pa и присваиваем ему адрес переменной a. Теперь pa указывает на a.
    double b = 24.3;           // Создаем переменную с плавающей запятой b и присваиваем ей значение 24.3.
    double *pb = &b;           // Создаем указатель на число с плавающей запятой pb и присваиваем ему адрес переменной b. Теперь pb указывает на b.

    // Выводим информацию о размере переменных и указателей
    std::cout << "int a = 5; \tSIZE = " << sizeof(a) << std::endl
              << "int* pa = &5; \tSIZE = " << sizeof(pa) << std::endl;

    std::cout << "double b = 24.3; \tSIZE = " << sizeof(b) << std::endl
              << "double* pb = &b; \tSIZE = " << sizeof(pb);

 
/*
Размеры переменных и указателей могут различаться на 32-битной и 64-битной архитектурах. 

На 32-битной архитектуре (где int обычно имеет размер 4 байта, а double - 8 байт):
int a = 5;         SIZE = 4
int* pa = &5;      SIZE = 4
double b = 24.3;   SIZE = 8
double* pb = &b;   SIZE = 4
Обратите внимание, что размер указателя на double остается 4 байта, несмотря на размер самой переменной double.

На 64-битной архитектуре (где int обычно имеет размер 4 байта, а double - 8 байт):
int a = 5;         SIZE = 4
int* pa = &5;      SIZE = 8
double b = 24.3;   SIZE = 8
double* pb = &b;   SIZE = 8
На 64-битной архитектуре размер указателя на int и double составляет 8 байт, 
так как она более подходит для работы с большими адресными пространствами.*/
    
std::cout << std::endl;

int arr[5] = {5, 6, 3, 14, 25};  // Создаем массив целых чисел arr с 5 элементами и инициализируем его значениями.

std::cout << arr << std::endl;   // Выводим адрес начала массива arr. Он будет выведен в шестнадцатеричной форме.
std::cout << *arr << std::endl;  // Выводим значение первого элемента массива arr. *arr разыменовывает указатель на начало массива.
std::cout << *arr + 1 << std::endl;  // Вычисляем значение выражения *arr + 1, которое равно первому элементу массива плюс 1.

int* parr = arr + 2;  // Создаем указатель parr и инициализируем его адресом третьего элемента массива arr (с индексом 2).

std::cout << *parr << std::endl;  // Выводим значение элемента массива, на который указывает parr, то есть третий элемент arr.
parr = arr + 3;  // Изменяем указатель parr, теперь он указывает на четвертый элемент массива arr (с индексом 3).
std::cout << *parr << std::endl;  // Выводим значение элемента массива, на который указывает обновленный parr.
parr = arr + 4;  // Изменяем указатель parr, теперь он указывает на пятый элемент массива arr (с индексом 4).
std::cout << *parr << std::endl;  // Выводим значение элемента массива, на который указывает обновленный parr.

std::cout << arr << " " << arr + 1 << std::endl; // 0x91301ff6b0 0x91301ff6b4

std::cout << std::endl;
double ar[5] = {1.2, 2.1, 3.2, 4.3, 5.3};

for (int i = 0; i < 5; i++)
{
    *(ar + i) *= 2; 
}
for (int i = 0; i < 5; i++)
{
    std::cout << "ar = " << *(ar + i) << std::endl;
}

/*
for (int i = 0; i < 5; i++)
{
    *(ar + i) *= 2; 
}
Первая итерация (i = 0):
*(ar + 0) *= 2; умножаем значение первого элемента, 
то есть 1.2, на 2. Теперь ar выглядит так: {2.4, 2.1, 3.2, 4.3, 5.3}.
Вторая итерация (i = 1):
*(ar + 1) *= 2; умножаем значение второго элемента, 
то есть 2.1, на 2. Теперь ar выглядит так: {2.4, 4.2, 3.2, 4.3, 5.3}.
Третья итерация (i = 2):
*(ar + 2) *= 2; умножаем значение третьего элемента, 
то есть 3.2, на 2. Теперь ar выглядит так: {2.4, 4.2, 6.4, 4.3, 5.3}.
Четвертая итерация (i = 3):
*(ar + 3) *= 2; умножаем значение четвертого элемента, 
то есть 4.3, на 2. Теперь ar выглядит так: {2.4, 4.2, 6.4, 8.6, 5.3}.
Пятая итерация (i = 4):
*(ar + 4) *= 2; умножаем значение пятого элемента, 
то есть 5.3, на 2. Теперь ar выглядит так: {2.4, 4.2, 6.4, 8.6, 10.6}.*/

   return 0;
}