#include <iostream>

int main()
{
    int *p;
    std::cout << p; // 0x8 некоторый адрес в шестнадцатеричном формате

    std::cout << std::endl;

    // Поскольку конкрентное значение не указано, указатель в качестве значения получает число 0.
    int *pa{};
    std::cout << pa << std::endl; // 0

    // Также можно явным образом инициализировать нулем, например, используя специальную константу nullptr:
    int *pb{nullptr};
    std::cout << pb << std::endl; // 0

    // определим указатель на объект типа int (название указателя) pc. В фигурных скобках {&c}
    // С помощью операция & (Амперса́нд) можно получить адрес некоторого объекта, например, адрес переменной.
    // Затем этот адрес можно присвоить указателю:
    int number = 3;
    int *pnumber{&number};              // указатель pnumber хранит адрес переменной number
    std::cout << *pnumber << std::endl; // 3
    // Выражение &number возвращает адрес переменной number.
    // Поэтому переменная pnumber будет хранить адрес переменной number.
    // Что важно, переменная number имеет тип int, и указатель, который указывает на ее адрес, тоже имеет тип int.
    // То есть должно быть соответствие по типу. Однако также можно использовать ключевое слово auto:
    int numberAuto = 3;
    auto *pnumberAuto{&numberAuto};     // указатель pnumberAuto хранит адрес переменной number
    std::cout << *pnumber << std::endl; // 3

    std::cout << "Адрес переменной pnumberAuto: " << pnumberAuto << std::endl;     // адрес переменной представляет шестнадцатиричное значение: 0x2e88dffc70
    std::cout << "Адрес переменной pnumberAuto: " << pnumberAuto + 1 << std::endl; // если прибавить 1, то следующий адрес такой  0x1ed99ffa24
    std::cout << "Адрес переменной pnumberAuto: " << pnumberAuto + 2 << std::endl; // если прибавить 2, то следующий адрес такой  0x1ed99ffa28

    std::cout << "Адрес *pnumberAuto: " << pnumberAuto << std::endl; // 0x583fbffcb0
    std::cout << "Адрес numberAuto: " << &numberAuto << std::endl;   // 0x583fbffcb0

    // Амперса́нд &
    // Переменные этих типов имеют разные размеры - 4 и 8 байт соответственно. Но размеры значений указателей будут одинаковы.
    // В моем случае на 64-разрядной платформе размер обоих указателей равен 8 байтам.
    int *pint{};
    double *pdouble{};
    std::cout << "int = " << sizeof(pint) << '\n'             // double = 8
              << "double = " << sizeof(pdouble) << std::endl; // double = 8

    // Получение значения по адресу
    int value = 25;
    int *pvalue{&value};
    std::cout << "Address = " << pvalue << std::endl
              << "Value = " << *pvalue << std::endl; // применяется операция * или операция разыменования ("indirection operator" / "dereference operator").

    // Значение, которое получено в результате операции разыменования, можно присвоить другой переменной:
    int i = 12;
    int *pi{&i};                                 // указатель pi1 хранит адрес переменной i
    int j{*pi};                                  // j получает значение, которое хранится по адресу в pi
    std::cout << "i = " << i << " " << std::endl // 12
              << "j = " << j << std::endl;       // 12

    // Используя указатель, мы можем менять значение по адресу, который хранится в указателе:
    int i1 = 23;
    std::cout << "i1 = " << i1 << std::endl; // 23
    int *pi1 = &i1;
    *pi1 = 56;
    std::cout << "*pi1 = " << *pi1 << " "    // 56
              << "i1 = " << i1 << std::endl; // 56
              
}